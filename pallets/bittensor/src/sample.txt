Okay, I understand. You want the calculations to naturally result in a `u16` without needing `saturated_into()` (which implies the logic itself should prevent intermediate values from vastly exceeding `u16::MAX` before the final averaging/blending). And the mechanism should strongly incentivize forming clusters (linked nodes).

The core issue leading to potential overflow, especially in `calculate_storage_miner_weights` and `calculate_validator_weights`, was how `own_weight` and `total_weight` (or `normalized_weight`) were combined.

Let's refine the logic with these principles:

**Core Principle for Clustered Node Weight:**
The score of a main node that is part of a cluster should be primarily determined by the **average performance of the entire cluster it belongs to (including itself)**. This inherently incentivizes having (good) linked nodes.

**Revised Calculation Logic (General Pattern):**

For each `miner` (which is a main node):

1.  **Calculate `own_weight_u32`:**
    *   Get metrics for the `miner.node_id`.
    *   `weight_u16 = WeightCalculation::calculate_weight(...)` for this main node.
    *   Perform an offline check for this main node. If offline, `weight_u16 = 0`.
    *   `own_weight_u32 = weight_u16 as u32`.

2.  **Calculate Weights of Linked Nodes and Their Contribution:**
    *   Initialize `total_weight_of_active_linked_nodes_u32 = 0`.
    *   Initialize `num_active_linked_nodes = 0`.
    *   Iterate through `linked_node_ids` for the current `miner`:
        *   Filter out linked nodes for which `ExecutionPallet::<T>::get_node_metrics()` returns `None`.
        *   For each valid linked node:
            *   `linked_node_weight_u16 = WeightCalculation::calculate_weight(...)` for this linked node.
            *   Perform an offline check for *this specific linked node* using `ExecutionPallet::<T>::block_numbers(linked_node_id.clone())`. If offline, `linked_node_weight_u16 = 0`.
            *   Store this `linked_node_weight_u16` in the respective `linked_XXX_miners_weights` vector.
            *   If `linked_node_weight_u16 > 0`:
                *   `total_weight_of_active_linked_nodes_u32 += linked_node_weight_u16 as u32`.
                *   `num_active_linked_nodes += 1`.

3.  **Determine `current_score_u32` for the Main Node:**
    *   If `num_active_linked_nodes > 0` (i.e., it's part of a cluster with at least one responsive, non-zero-weight linked node):
        *   The main node's score reflects the average of itself AND its active linked partners.
        *   `current_score_u32 = (own_weight_u32 + total_weight_of_active_linked_nodes_u32) / (1 + num_active_linked_nodes) as u32;`
    *   Else (it's a standalone node or all its linked nodes are inactive/zero-weight):
        *   `current_score_u32 = own_weight_u32;`

4.  **Apply Blending (if applicable for the node type):**
    *   For types like Storage Miners and Validators that use blending:
        *   `previous_rankings = RankingsPallet::<T, Instance_Maybe>::get_node_ranking(...)`.
        *   `final_blended_score_u32 = ((1 * current_score_u32) + (9 * previous_rankings.weight as u32)) / 10` (or similar factors).
    *   For types that don't use blending, `final_blended_score_u32 = current_score_u32`.

5.  **Store the Final Weight as `u16`:**
    *   `final_score_u16 = final_blended_score_u32 as u16;`
    *   Push `final_score_u16` to the main `XXX_weights` vector (e.g., `storage_weights`).

**Why this should work and avoid overflow (without `saturated_into`):**

*   **Averaging:** The key is that `current_score_u32` is an average. If `WeightCalculation::calculate_weight` produces values that are conceptually `u16` (i.e., 0-65535), then the average of such values will also be within that 0-65535 range.
*   **Blending:** The blending formula `(1 * new + 9 * old) / 10` is a weighted average, so it will also keep the result within the same general magnitude as its inputs.
*   **Assumption:** This relies on `WeightCalculation::calculate_weight(...)` returning a `u16` (or a value that fits within `u16` after its internal logic). The fact that you often do `weight as u16` for linked node lists supports this.

Let's apply this refined logic specifically.

**1. `calculate_storage_miner_weights` (and `calculate_validator_weights` by strong analogy):**

```rust
impl<T: Config> Pallet<T> {
    fn calculate_storage_miner_weights(
        all_miners: &Vec<NodeInfo<BlockNumberFor<T>, T::AccountId>>,
        all_nodes_metrics: &Vec<NodeMetricsData>, // Global metrics for context
        uids: &Vec<UID>, // Bittensor UIDs
    ) -> ( /* ... return types ... */ ) {
        // ... initializations of output vectors ...
        let mut storage_weights: Vec<u16> = Vec::new();
        let mut storage_nodes_ss58: Vec<Vec<u8>> = Vec::new();
        // ... other main node result vectors ...
        let mut linked_storage_miners_weights: Vec<u16> = Vec::new();
        // ... other linked node result vectors ...

        for miner in all_miners {
            if miner.node_type != NodeType::StorageMiner {
                continue;
            }

            let mut geo_distribution: BTreeMap<Vec<u8>, u32> = BTreeMap::new(); // Reset per main miner for its cluster context

            // 1. Calculate own_weight_u32 for the main node
            let mut own_weight_u32: u32 = 0;
            if let Some(metrics) = ExecutionPallet::<T>::get_node_metrics(miner.node_id.clone()) {
                geo_distribution.insert(metrics.geolocation.clone(), 1);
                let mut weight_main_node_u16 = WeightCalculation::calculate_weight::<T>(
                    NodeType::StorageMiner,
                    &metrics,
                    all_nodes_metrics, // Pass all_nodes_metrics
                    &geo_distribution,
                    &miner.owner,
                );

                let current_block_number = <frame_system::Pallet<T>>::block_number();
                let buffer = 300u32;
                let blocks_online = ExecutionPallet::<T>::block_numbers(miner.node_id.clone());
                if let Some(blocks) = blocks_online {
                    if let Some(&last_block) = blocks.last() {
                        if (current_block_number - last_block) > buffer.into() {
                            weight_main_node_u16 = 0;
                        }
                    } else { weight_main_node_u16 = 0; /* No blocks recorded */ }
                } else { weight_main_node_u16 = 0; /* No online info */ }
                own_weight_u32 = weight_main_node_u16 as u32;
            } else {
                log::info!("Node metrics not found for main storage miner: {:?}", miner.node_id);
                // own_weight_u32 remains 0
            }

            // 2. Calculate Weights of Linked Nodes
            let mut linked_node_ids = LinkedNodes::<T>::get(&miner.node_id);
            let mut total_weight_of_active_linked_nodes_u32: u32 = 0;
            let mut num_active_linked_nodes: usize = 0;

            // Retain only linked nodes that have metrics (important optimization)
            linked_node_ids.retain(|id| ExecutionPallet::<T>::get_node_metrics(id.clone()).is_some());

            for linked_node_id in &linked_node_ids {
                // Metrics should exist due to retain above, but `if let` is safer
                if let Some(metrics_linked) = ExecutionPallet::<T>::get_node_metrics(linked_node_id.clone()) {
                    geo_distribution.insert(metrics_linked.geolocation.clone(), 1); // Add linked node's geo to cluster's geo_dist

                    let mut weight_linked_node_u16 = WeightCalculation::calculate_weight::<T>(
                        NodeType::StorageMiner, // Assuming linked nodes are of the same type
                        &metrics_linked,
                        all_nodes_metrics, // Pass all_nodes_metrics
                        &geo_distribution,
                        &miner.owner, // Cluster is identified by main miner's owner
                    );

                    let current_block_number = <frame_system::Pallet<T>>::block_number();
                    let buffer = 300u32;
                    // CRITICAL: Use linked_node_id for its own offline check
                    let blocks_online_linked = ExecutionPallet::<T>::block_numbers(linked_node_id.clone());
                    if let Some(blocks) = blocks_online_linked {
                        if let Some(&last_block) = blocks.last() {
                            if (current_block_number - last_block) > buffer.into() {
                                weight_linked_node_u16 = 0;
                            }
                        } else { weight_linked_node_u16 = 0; }
                    } else { weight_linked_node_u16 = 0; }

                    // Populate linked node details (even if weight is 0, for record keeping)
                    if let Some(linked_node_info) = RegistrationPallet::<T>::get_node_registration_info(linked_node_id.clone()) {
                        let linked_miner_ss58_str = AccountId32::new(linked_node_info.owner.encode().try_into().unwrap_or_default()).to_ss58check();
                        linked_storage_miners_ss58.push(linked_miner_ss58_str.into());
                        linked_storage_miners_node_id.push(linked_node_id.clone());
                        linked_storage_miners_node_types.push(NodeType::StorageMiner);
                        linked_storage_miners_weights.push(weight_linked_node_u16);
                    }
                    
                    if weight_linked_node_u16 > 0 {
                        total_weight_of_active_linked_nodes_u32 += weight_linked_node_u16 as u32;
                        num_active_linked_nodes += 1;
                    }
                }
            }

            // 3. Determine current_score_u32 for the Main Node
            let current_score_u32: u32;
            if num_active_linked_nodes > 0 {
                // Score is the average of the main node AND its active linked nodes
                current_score_u32 = (own_weight_u32 + total_weight_of_active_linked_nodes_u32) / (1 + num_active_linked_nodes) as u32;
            } else {
                // Standalone node or cluster with no active linked members
                current_score_u32 = own_weight_u32;
            }

            // 4. Apply Blending
            let previous_rankings = RankingsPallet::<T>::get_node_ranking(miner.node_id.clone()); // Default instance for StorageMiner
            let final_blended_score_u32 = match previous_rankings {
                Some(rankings) => ((1 * current_score_u32) + (9 * rankings.weight as u32)) / 10,
                None => current_score_u32,
            };

            // 5. Store the Final Weight as u16
            storage_weights.push(final_blended_score_u32 as u16);

            // Populate main miner's details
            let miner_ss58 = AccountId32::new(miner.owner.encode().try_into().unwrap_or_default()).to_ss58check();
            storage_miners_node_id.push(miner.node_id.clone());
            storage_miners_node_types.push(miner.node_type.clone());
            storage_nodes_ss58.push(miner_ss58.clone().into());

            // Bittensor UID matching
            for uid_info in uids.iter() {
                if uid_info.substrate_address.to_ss58check() == miner_ss58 {
                    // `all_weights_on_bitensor` should reflect the final_blended_score_u32
                    // ... (populate all_uids_on_bittensor, all_weights_on_bitensor using final_blended_score_u32 as u16)
                }
            }
        }
        // ... return all populated vectors ...
        (
            storage_weights,
            storage_nodes_ss58,
            storage_miners_node_id,
            storage_miners_node_types,
            /* all_uids_on_bittensor, all_weights_on_bitensor needs to be filled above */
            Vec::new(), // Placeholder for all_uids_on_bittensor
            Vec::new(), // Placeholder for all_weights_on_bitensor
            linked_storage_miners_weights,
            linked_storage_miners_ss58,
            linked_storage_miners_node_id,
            linked_storage_miners_node_types,
        )
    }
    // ...
}
```

**Modifications for `calculate_validator_weights`:**
*   Use `NodeType::Validator`.
*   Use `RankingsPallet::<T, pallet_rankings::Instance3>::get_node_ranking(...)` for previous rankings.
*   The rest of the logic follows the same pattern as `calculate_storage_miner_weights`.

**Modifications for `calculate_storage_s3_weights`, `calculate_gpu_miner_weights`, `calculate_compute_miner_weights`:**
These originally did *not* have the blending step if linked nodes were present.
*   Follow steps 1, 2, 3 as above.
*   For step 4 (Blending): If these types are not meant to have blending, then `final_blended_score_u32 = current_score_u32;`.
*   Step 5 remains: `XXX_weights.push(final_blended_score_u32 as u16);`

**Example snippet for `calculate_storage_s3_weights` (illustrating no blending):**
```rust
// ... (Steps 1, 2 as in storage_miner_weights, using NodeType::StorageS3) ...

// 3. Determine current_score_u32 for the Main S3 Node
let current_score_u32: u32;
if num_active_linked_nodes > 0 {
    current_score_u32 = (own_weight_u32 + total_weight_of_active_linked_nodes_u32) / (1 + num_active_linked_nodes) as u32;
} else {
    current_score_u32 = own_weight_u32;
}

// 4. No Blending (as per original structure for S3/GPU/Compute when clustered)
let final_score_u32 = current_score_u32;

// 5. Store the Final Weight as u16
storage_s3_weights.push(final_score_u32 as u16);

// ... rest of the logic for main S3 miner and its Bittensor UIDs ...
```

**Key Fixes Incorporated:**
1.  **Logical Weight Combination:** The core change is how `own_weight_u32` and linked node weights are combined into `current_score_u32` (using averaging for the whole cluster). This inherently rewards clustering and should keep values in `u16` range if base weights are `u16`-scaled.
2.  **Correct Offline Check for Linked Nodes:** Crucially, `ExecutionPallet::<T>::block_numbers(linked_node_id.clone())` is used when checking the status of a *linked node*, not `miner.node_id.clone()`.
3.  **Active Linked Nodes Only:** Only linked nodes that are online and have a weight greater than 0 contribute to `total_weight_of_active_linked_nodes_u32` and `num_active_linked_nodes`. This prevents a single dead linked node from unfairly penalizing a cluster.
4.  **Consistent Ranking Instance:** Using the correct pallet instance for validator rankings.
5.  **Geo-distribution Context:** `geo_distribution` is built per main miner, including its linked nodes, which seems reasonable for evaluating cluster diversity. `all_nodes_metrics` is passed to `WeightCalculation::calculate_weight` for broader network context if needed by that function.

This revised approach should give you the desired `u16` weights without overflow, while strongly incentivizing the formation of healthy, active clusters. Remember to carefully implement the Bittensor UID and weight population using the `final_blended_score_u32 as u16` (or `final_score_u32 as u16` for non-blended types).