//! Autogenerated weights for `pallet_arion`
//!
//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0
//! (with manual estimation as baseline - run actual benchmarks in your runtime)
//!
//! To regenerate with actual benchmarks:
//! ```bash
//! ./target/release/your-node benchmark pallet \
//!     --chain=dev \
//!     --pallet=pallet_arion \
//!     --extrinsic=* \
//!     --steps=50 \
//!     --repeat=20 \
//!     --output=pallets/arion/src/weights.rs
//! ```

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(missing_docs)]

use frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};
use sp_std::marker::PhantomData;

/// Weight functions needed for pallet_arion.
pub trait WeightInfo {
    fn submit_crush_map(n: u32) -> Weight;
    fn submit_miner_stats(n: u32) -> Weight;
    fn submit_node_quality(n: u32) -> Weight;
    fn submit_attestations(n: u32) -> Weight;
    fn submit_attestation_commitment() -> Weight;
    fn register_child() -> Weight;
    fn deregister_child() -> Weight;
    fn claim_unbonded() -> Weight;
    fn set_lockup_enabled() -> Weight;
    fn set_base_child_deposit() -> Weight;
    fn register_warden() -> Weight;
    fn deregister_warden() -> Weight;
    fn prune_attestation_buckets(n: u32) -> Weight;
}

/// Weights for pallet_arion using the Substrate node and recommended hardware.
pub struct SubstrateWeight<T>(PhantomData<T>);

impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {
    /// Storage: Arion CurrentEpoch (r:1 w:1)
    /// Storage: Arion CrushMap (r:0 w:1)
    /// Storage: Arion CrushParams (r:0 w:1)
    /// Storage: Arion MapRootHash (r:0 w:1)
    /// The weight includes `n` miners being processed.
    fn submit_crush_map(n: u32) -> Weight {
        // Base: read epoch + write 4 storage items
        // Per miner: bounded vec encoding overhead
        Weight::from_parts(25_000_000, 0)
            .saturating_add(Weight::from_parts(500_000, 0).saturating_mul(n.into()))
            .saturating_add(T::DbWeight::get().reads(1))
            .saturating_add(T::DbWeight::get().writes(4))
    }

    /// Storage: Arion LastStatsBucket (r:1 w:1)
    /// Storage: Arion MinerStats (r:0 w:n)
    /// Storage: Arion TotalShards (r:1 w:1)
    /// Storage: Arion TotalBandwidthBytes (r:1 w:1)
    fn submit_miner_stats(n: u32) -> Weight {
        // Base: read/write aggregate state
        // Per miner: write stats entry
        Weight::from_parts(15_000_000, 0)
            .saturating_add(Weight::from_parts(2_000_000, 0).saturating_mul(n.into()))
            .saturating_add(T::DbWeight::get().reads(3))
            .saturating_add(T::DbWeight::get().writes(3))
            .saturating_add(T::DbWeight::get().writes(n.into()))
    }

    /// Storage: Arion CurrentWeightBucket (r:1 w:1)
    /// Storage: Arion ChildRegistrations (r:n w:0) - verify each child is registered
    /// Storage: Arion NodeQuality (r:0 w:n)
    /// Storage: Arion NodeWeightByChild (r:0 w:n)
    /// Storage: Arion FamilyWeight (r:n w:n) - read and write for each family
    /// Storage: Arion FamilyFirstSeenBucket (r:n w:0) - newcomer check
    fn submit_node_quality(n: u32) -> Weight {
        // Base cost + per-node writes + family weight recalculation
        // Family weight calculation involves log2 operations and EMA
        // Reads: 1 base + n child registrations + n family weights + n first seen buckets
        // Writes: 1 base + n qualities + n node weights + n family weights
        Weight::from_parts(20_000_000, 0)
            .saturating_add(Weight::from_parts(5_000_000, 0).saturating_mul(n.into()))
            .saturating_add(T::DbWeight::get().reads(1)) // CurrentWeightBucket
            .saturating_add(T::DbWeight::get().reads(n.into())) // ChildRegistrations
            .saturating_add(T::DbWeight::get().reads(n.into())) // FamilyWeight reads
            .saturating_add(T::DbWeight::get().reads(n.into())) // FamilyFirstSeenBucket
            .saturating_add(T::DbWeight::get().writes(1)) // CurrentWeightBucket
            .saturating_add(T::DbWeight::get().writes(n.into())) // NodeQuality
            .saturating_add(T::DbWeight::get().writes(n.into())) // NodeWeightByChild
            .saturating_add(T::DbWeight::get().writes(n.into())) // FamilyWeight
    }

    /// Storage: Arion AuditResults (r:n w:n)
    /// Per attestation:
    /// - Ed25519 signature verification (~50,000 gas equivalent)
    /// - SCALE encoding for signature message
    /// - Storage write
    fn submit_attestations(n: u32) -> Weight {
        // Ed25519 verification is the dominant cost (~50us per signature on reference hardware)
        // SCALE encoding of signing message adds overhead
        // Storage writes for each attestation result
        let base = Weight::from_parts(10_000_000, 0);
        let per_attestation = Weight::from_parts(
            // Ed25519 verify: ~50,000,000 pico-seconds (50us)
            // SCALE encode: ~5,000,000 pico-seconds (5us)
            // Storage: ~10,000,000 pico-seconds (10us)
            65_000_000,
            0
        );

        base
            .saturating_add(per_attestation.saturating_mul(n.into()))
            .saturating_add(T::DbWeight::get().reads(n.into()))
            .saturating_add(T::DbWeight::get().writes(n.into()))
    }

    /// Storage: Arion EpochAttestationCommitments (r:1 w:1)
    fn submit_attestation_commitment() -> Weight {
        Weight::from_parts(15_000_000, 0)
            .saturating_add(T::DbWeight::get().reads(1))
            .saturating_add(T::DbWeight::get().writes(1))
    }

    /// Storage: Arion ChildRegistrations (r:1 w:1)
    /// Storage: Arion FamilyChildren (r:1 w:1)
    /// Storage: Arion NodeIdToChild (r:1 w:1)
    /// Storage: Arion GlobalNextDeposit (r:1 w:1)
    /// Storage: System Account (r:1 w:1) for reserve
    /// Ed25519 signature verification
    fn register_child() -> Weight {
        Weight::from_parts(100_000_000, 0)
            .saturating_add(T::DbWeight::get().reads(5))
            .saturating_add(T::DbWeight::get().writes(5))
    }

    /// Storage: Arion ChildRegistrations (r:1 w:1)
    /// Storage: Arion FamilyChildren (r:1 w:1)
    /// Storage: Arion NodeIdToChild (r:0 w:1)
    fn deregister_child() -> Weight {
        Weight::from_parts(40_000_000, 0)
            .saturating_add(T::DbWeight::get().reads(2))
            .saturating_add(T::DbWeight::get().writes(3))
    }

    /// Storage: Arion ChildRegistrations (r:1 w:1)
    /// Storage: System Account (r:1 w:1) for unreserve
    fn claim_unbonded() -> Weight {
        Weight::from_parts(35_000_000, 0)
            .saturating_add(T::DbWeight::get().reads(2))
            .saturating_add(T::DbWeight::get().writes(2))
    }

    /// Storage: Arion LockupEnabled (r:0 w:1)
    fn set_lockup_enabled() -> Weight {
        Weight::from_parts(5_000_000, 0)
            .saturating_add(T::DbWeight::get().writes(1))
    }

    /// Storage: Arion BaseChildDepositValue (r:0 w:1)
    fn set_base_child_deposit() -> Weight {
        Weight::from_parts(5_000_000, 0)
            .saturating_add(T::DbWeight::get().writes(1))
    }

    /// Storage: Arion RegisteredWardens (r:1 w:1)
    fn register_warden() -> Weight {
        Weight::from_parts(20_000_000, 0)
            .saturating_add(T::DbWeight::get().reads(1))
            .saturating_add(T::DbWeight::get().writes(1))
    }

    /// Storage: Arion RegisteredWardens (r:1 w:1)
    fn deregister_warden() -> Weight {
        Weight::from_parts(20_000_000, 0)
            .saturating_add(T::DbWeight::get().reads(1))
            .saturating_add(T::DbWeight::get().writes(1))
    }

    /// Storage: Arion AttestationsByBucket (r:n w:n)
    /// Per bucket: check if exists, then remove all attestations for that bucket
    fn prune_attestation_buckets(n: u32) -> Weight {
        // Each bucket removal requires checking existence and clearing storage
        Weight::from_parts(10_000_000, 0)
            .saturating_add(Weight::from_parts(5_000_000, 0).saturating_mul(n.into()))
            .saturating_add(T::DbWeight::get().reads(n.into())) // contains_key checks
            .saturating_add(T::DbWeight::get().writes(n.into())) // remove_prefix calls
    }
}

/// For backwards compatibility and testnets
impl WeightInfo for () {
    fn submit_crush_map(n: u32) -> Weight {
        Weight::from_parts(25_000_000, 0)
            .saturating_add(Weight::from_parts(500_000, 0).saturating_mul(n.into()))
            .saturating_add(RocksDbWeight::get().reads(1))
            .saturating_add(RocksDbWeight::get().writes(4))
    }

    fn submit_miner_stats(n: u32) -> Weight {
        Weight::from_parts(15_000_000, 0)
            .saturating_add(Weight::from_parts(2_000_000, 0).saturating_mul(n.into()))
            .saturating_add(RocksDbWeight::get().reads(3))
            .saturating_add(RocksDbWeight::get().writes(3))
            .saturating_add(RocksDbWeight::get().writes(n.into()))
    }

    fn submit_node_quality(n: u32) -> Weight {
        Weight::from_parts(20_000_000, 0)
            .saturating_add(Weight::from_parts(5_000_000, 0).saturating_mul(n.into()))
            .saturating_add(RocksDbWeight::get().reads(1)) // CurrentWeightBucket
            .saturating_add(RocksDbWeight::get().reads(n.into())) // ChildRegistrations
            .saturating_add(RocksDbWeight::get().reads(n.into())) // FamilyWeight reads
            .saturating_add(RocksDbWeight::get().reads(n.into())) // FamilyFirstSeenBucket
            .saturating_add(RocksDbWeight::get().writes(1)) // CurrentWeightBucket
            .saturating_add(RocksDbWeight::get().writes(n.into())) // NodeQuality
            .saturating_add(RocksDbWeight::get().writes(n.into())) // NodeWeightByChild
            .saturating_add(RocksDbWeight::get().writes(n.into())) // FamilyWeight
    }

    fn submit_attestations(n: u32) -> Weight {
        Weight::from_parts(10_000_000, 0)
            .saturating_add(Weight::from_parts(65_000_000, 0).saturating_mul(n.into()))
            .saturating_add(RocksDbWeight::get().reads(n.into()))
            .saturating_add(RocksDbWeight::get().writes(n.into()))
    }

    fn submit_attestation_commitment() -> Weight {
        Weight::from_parts(15_000_000, 0)
            .saturating_add(RocksDbWeight::get().reads(1))
            .saturating_add(RocksDbWeight::get().writes(1))
    }

    fn register_child() -> Weight {
        Weight::from_parts(100_000_000, 0)
            .saturating_add(RocksDbWeight::get().reads(5))
            .saturating_add(RocksDbWeight::get().writes(5))
    }

    fn deregister_child() -> Weight {
        Weight::from_parts(40_000_000, 0)
            .saturating_add(RocksDbWeight::get().reads(2))
            .saturating_add(RocksDbWeight::get().writes(3))
    }

    fn claim_unbonded() -> Weight {
        Weight::from_parts(35_000_000, 0)
            .saturating_add(RocksDbWeight::get().reads(2))
            .saturating_add(RocksDbWeight::get().writes(2))
    }

    fn set_lockup_enabled() -> Weight {
        Weight::from_parts(5_000_000, 0)
            .saturating_add(RocksDbWeight::get().writes(1))
    }

    fn set_base_child_deposit() -> Weight {
        Weight::from_parts(5_000_000, 0)
            .saturating_add(RocksDbWeight::get().writes(1))
    }

    fn register_warden() -> Weight {
        Weight::from_parts(20_000_000, 0)
            .saturating_add(RocksDbWeight::get().reads(1))
            .saturating_add(RocksDbWeight::get().writes(1))
    }

    fn deregister_warden() -> Weight {
        Weight::from_parts(20_000_000, 0)
            .saturating_add(RocksDbWeight::get().reads(1))
            .saturating_add(RocksDbWeight::get().writes(1))
    }

    fn prune_attestation_buckets(n: u32) -> Weight {
        Weight::from_parts(10_000_000, 0)
            .saturating_add(Weight::from_parts(5_000_000, 0).saturating_mul(n.into()))
            .saturating_add(RocksDbWeight::get().reads(n.into())) // contains_key checks
            .saturating_add(RocksDbWeight::get().writes(n.into())) // remove_prefix calls
    }
}